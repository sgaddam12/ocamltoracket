#lang racket

;; Opaque library providing function signatures (w/o implementation)

(module prog-4424 racket
  ;;(require (submod ".." lib))
  
  (provide
   (contract-out
    [eval (expr/c expr/c expr/c . -> . number?)]
    [ffor (number? number? (number? . -> . number?) . -> . '())]
    [toIntensity (integer? . -> . real?)]
    [toReal (integer? integer? . -> . real?)]
    [build ((#:x any/c #:y any/c . -> . (or/c #:x #:y)) integer? . -> . string?)]))
  
  ;; Translate each ocaml variant into a struct. Field names are arbitary
  (struct VarX ())
  (struct VarY ())
  (struct Sine (e1))
  (struct Cosine (e1))
  (struct Average (e1 e2))
  (struct Times (e1 e2))
  (struct Thresh (e1 e2 e3 e4))
  (struct Factorial (e1))
    
  ;; Define contract corresponding to ocaml type
  (define expr/c
    (Î¼/c (X)
         (or/c (struct/c VarX)
               (struct/c VarY)
               (struct/c Sine X)
               (struct/c Cosine X)
               (struct/c Average X X)
               (struct/c Times X X)
               (struct/c Thresh X X X X)
               (struct/c Factorial X))))

    (define (eval e x y)
      (match e
        [(VarX) x]
        [(VarY) y]
        [(Sine e1)
         (sin (* pi (eval e1 x y)))]
        [(Cosine e1)
         (cos (* pi (eval e1 x y)))]
        [(Average e1 e2)
         (/ (+ (eval e1 x y) (eval e2 x y)) 2.0)]
        [(Times e1 e2)
         (* (eval e1 x y) (eval e2 x y))]
        [(Thresh e1 e2 e3 e4)
         (cond
           [(< (eval e1 x y) (eval e2 x y)) (eval e3 x y)]
           [else (eval e4 x y)])]
        )
      )

  (define (ffor low high f)
    (cond
      [(> low high) '()]
      [else (let ([temp (f low)]) (ffor (+ low 1) high f))]))

  (define (toIntensity z)
    (+ 127.5 (* 127.5 z)))

  (define (toReal i n)
    (/ i n))

  (define (build rand depth)
    (letrec ([(buildhelper num depth expr)
              (cond
                [(= num 0)
                 (cond
                   [(= (rand 0 1) 0) (string-append expr "VarX")]
                   [else (string-append expr "VarY")])]
                [(= num 1)
                 (cond
                   [(= (rand 0 1) 0) (string-append "Sine(" (string-append (buildhelper 0 (- depth 1) expr) ")"))]
                   [else (string-append "Cosine(" (string-append (buildhelper 0 (- depth 1) expr) ")"))])
                 [(= num 2)
                  (cond
                    [(= (rand 0 1) 0) (string-append expr (string-append "(("
                                                                         (string-append (buildhelper (rand 0 (- depth 1)) (- depth 1) expr) (string-append "+" (string-append (buildhelper (rand 0 (- depth 1)) (- depth 1) expr) ")/2)")))))]  
                    [else (string-append expr (string-append (buildhelper (rand 0 (- depth 1)) (- depth 1) expr) (string-append "*" (buildhelper (rand 0 (- depth 1)) (- depth 1) expr))))])]
                 [(= num 4) (string-append expr (string-append "(" (string-append (buildhelper (rand 0 (- depth 1)) (- depth 1) expr) (string-append "<" (string-append (buildhelper (rand 0 (- depth 1)) (- depth 1) expr) (string-append "?" (string-append (buildhelper (rand 0 (- depth 1)) (- depth 1) expr) (string-append ":" (string-append (buildhelper (rand 0 (- depth 1)) (- depth 1) expr) ")")))))))))]])])
      (buildhelper (rand 0 4) depth ""))
    )
  )